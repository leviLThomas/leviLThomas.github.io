[{"content":"","description":null,"image":null,"permalink":"https://levithomas.dev/about/","title":"About Me"},{"content":"","description":null,"image":null,"permalink":"https://levithomas.dev/hero/","title":"Levi."},{"content":"\u003cp\u003eIn this project, I developed a server-side application that efficiently calculates the shortest path between two points in Edmonton, using a graph-based approach. The application was primarily intended to interact with a client-side map interface where users can select points directly.\u003c/p\u003e\n\u003ch3 id=\"implementation-details\"\u003eImplementation Details\u003c/h3\u003e\n\u003cp\u003eThe core of the application was built in C++, utilizing Dijkstra\u0026rsquo;s algorithm to navigate through a weighted directed graph representing Edmonton\u0026rsquo;s road network. The coordinates were based on actual geographical data, and paths were calculated using the Manhattan distance to approximate real-world travel distances between points.\u003c/p\u003e\n\u003ch4 id=\"key-components\"\u003eKey Components:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGraph Construction:\u003c/strong\u003e The road network was represented as a graph where intersections and road segments were nodes and edges, respectively. I used adjacency lists for efficient graph traversal.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDijkstra\u0026rsquo;s Algorithm:\u003c/strong\u003e Implemented to determine the shortest path from a selected start point to an end point. The algorithm was optimized for performance to handle real-time user requests.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eServer Design:\u003c/strong\u003e I designed the server to handle requests from a client-side application, receive geographic coordinates, and return the shortest path in a format that could be easily displayed on the map.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"technical-highlights\"\u003eTechnical Highlights\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eData Parsing:\u003c/strong\u003e Implemented efficient parsing mechanisms to convert the Edmonton road dataset into a usable graph format, ensuring data integrity and accuracy.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIPC (Inter-Process Communication):\u003c/strong\u003e Utilized to manage communication between the server and client applications, ensuring robust data handling and response delivery.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOptimization:\u003c/strong\u003e Focused on optimizing the graph traversal process to minimize response times, which was crucial for maintaining a smooth user experience.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"challenges-and-solutions\"\u003eChallenges and Solutions\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eHandling Large Datasets:\u003c/strong\u003e The major challenge was managing and searching through large datasets representing the city\u0026rsquo;s roads. I addressed this by optimizing the graph data structures and streamlining the pathfinding algorithm to improve performance.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAccuracy of Pathfinding:\u003c/strong\u003e Ensuring the accuracy of the generated paths was essential. I refined the geographic coordinate handling and adjusted the Manhattan distance calculations to better reflect the urban grid.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\u003cp\u003eThe Edmonton GPS Pathfinder project was an excellent opportunity to deepen my understanding of graph algorithms and their applications in real-world scenarios. It challenged me to apply theoretical concepts in a practical, user-oriented application and honed my skills in data structures, algorithms, and system design. The project not only improved my technical acumen but also enhanced my ability to translate complex requirements into efficient and reliable software solutions.\u003c/p\u003e\n","description":"An interactive map that calculates the shortest path between two points in Edmonton utilizing Dijkstras algorithm on a weighted directed graph.","image":null,"permalink":"https://levithomas.dev/projects/edmontongps/edmontongps/","title":"Edmonton GPS Pathfinder"},{"content":"\u003cp\u003eUsing C as the primary programming language, I developed both server and client components that handle game logic and player interactions. The game simulates a scenario where each player targets the next in a circular sequence, attempting to locate and destroy a single-dot ship on their opponent\u0026rsquo;s grid.\u003c/p\u003e\n\u003ch2 id=\"roadmap\"\u003eRoadmap\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Thread-safe Logging\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Unit Testing\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Fuzz Testing\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Integration Testing\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Cross-Platform Compatibility\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e CI/CD Pipeline\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Serialization\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Docs\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e TUI?\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"original-requirements\"\u003eOriginal Requirements\u003c/h2\u003e\n\u003cp\u003eBattleDot is based off an assignment I was given in the past, the original requirements are as follows:\u003c/p\u003e\n\u003ch3 id=\"technical-requirements\"\u003eTechnical Requirements\u003c/h3\u003e\n\u003cp\u003ePlease implement a Linux-running program in\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e C\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e C++\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Python\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Java\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe whole implementation needs to start with one command (program/script in any language).\nThe game plays by itself after it starts, it is not interactive/does not require input.\u003c/p\u003e\n\u003ch3 id=\"problem-statement\"\u003eProblem Statement\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eRather than having two players oppose each other directly, any player will be attacked by one opponent and in turn will attack a different opponent.\u003c/li\u003e\n\u003cli\u003ePlayers are connected in a ring: A is bombing B who is bombing C, \u0026hellip; who is bombing Z who is bombing A.\u003c/li\u003e\n\u003cli\u003eEach player has a 10x10 grid of \u0026ldquo;dots\u0026rdquo; where one \u0026ldquo;single-dot ship\u0026rdquo; is positioned randomly.\u003c/li\u003e\n\u003cli\u003eA player loses if this ship is bombed\u003c/li\u003e\n\u003cli\u003ePlayers cannot see each other\u0026rsquo;s grids directly.\u003c/li\u003e\n\u003cli\u003eEach player randomly selects a dot location on the enemy grid to bomb and sends the bomb to the enemy.\u003c/li\u003e\n\u003cli\u003eIf the bomb lands in the enemy\u0026rsquo;s dot-ship, the enemy dies; otherwise, it lives.\u003c/li\u003e\n\u003cli\u003eWhen a player dies, relevant neighbors are matched up so that their unfinished games can continue.\u003c/li\u003e\n\u003cli\u003eMust create a log file\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"bonus-points\"\u003eBonus Points\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e A multi-threaded program, or a multi-process program, where the processes communicate using IPC of your choice.\u003c/li\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e If a process leaves the game (for ex. by an external signal), their neighbors become similarly matched up.\u003c/li\u003e\n\u003cli\u003e\u003cinput checked=\"\" disabled=\"\" type=\"checkbox\"\u003e The solution must use connections that could work between multiple computers.\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e A new player can be added to BattleDotNet by specifying two adjacent nodes in the BattleDotNet.\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled=\"\" type=\"checkbox\"\u003e Implement without a \u0026ldquo;master\u0026rdquo; node - only peer-to-peer\u003c/li\u003e\n\u003c/ul\u003e\n","description":"A game derived from Battleship where players attack in a ring formation.","image":{"href":"https://www.vectorstock.com/royalty-free-vector/in-paper-sticker-style-sea-vector-15555384","src":"/images/battledot.png"},"permalink":"https://levithomas.dev/projects/battledot/battledot/","title":"BattleDot: An Exercise in Networked Multi-threading"},{"content":"\u003cp\u003eA web app written using Rust and WebAssembly to play connect 4 against a computer opponent\u003c/p\u003e\n","description":"A web app written using Rust and WebAssembly to play connect 4 against a computer opponent","image":null,"permalink":"https://levithomas.dev/projects/connect4/connect4/","title":"Connect4"}]